// Copyright Steinwurf ApS 2018.
// Distributed under the "STEINWURF EVALUATION LICENSE 1.0".
// See accompanying file LICENSE.rst or
// http://www.steinwurf.com/licensing

#include <stdint.h>
#include <stdlib.h>
#include <kodo_rlnc_c/encoder.h>

#ifdef _WIN32
    #include <winsock2.h>
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <netdb.h>
    #include <unistd.h>
    #include <sys/time.h>
#endif

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <assert.h>

#ifdef _WIN32

#include <windows.h>

void sleep_here(uint32_t milliseconds)
{
    Sleep(milliseconds);
}

#else

void sleep_here(uint32_t milliseconds)
{
    usleep(milliseconds * 1000); // takes microseconds
}

#endif


int main(int argc, char* argv[])
{
    // Variables needed for the network / socket usage
    int32_t socket_descriptor;
    int32_t return_code;
    uint32_t i;

    struct sockaddr_in local_address;
    struct sockaddr_in remote_address;
    struct hostent* host;

    uint32_t delay = 0; // Delay between packets

    // Variables needed for the coding
    uint32_t symbols = 32;
    uint32_t symbol_size = 160;
    int32_t finite_field = krlnc_binary8;

    uint32_t packets = 0;

    krlnc_encoder_t encoder = NULL;

    // The buffer sent to the receiver
    uint32_t payload_size = 0;
    uint8_t* payload = 0;
    uint32_t bytes_used = 0;

    // The data to be encoded
    uint32_t block_size = 0;
    uint8_t* data_in = 0;

    // Initialize winsock if on Windows
#ifdef _WIN32

    WORD versionWanted = MAKEWORD(1, 1);
    WSADATA wsaData;

    return_code = WSAStartup(versionWanted, &wsaData);

    if (return_code != 0)
    {
        // Tell the user that we could not find a usable
        // Winsock DLL.
        printf("WSAStartup failed with error: %d\n", return_code);
        exit(1);
    }

#endif

    // Check command line args
    if (argc != 6)
    {
        printf("usage : %s <server> <port> <symbols> <packets> <delay_ms>\n",
               argv[0]);

        exit(1);
    }

    // Get the delay
    delay = atol(argv[5]);
    printf("Delay is: %u milliseconds\n", delay);

    // Get server IP address (no check if input is IP address or DNS name)
    host = gethostbyname(argv[1]);
    if (host == NULL)
    {
        printf("%s: unknown host '%s' \n", argv[0], argv[1]);
        exit(1);
    }

    printf("Sending data to '%s:%d' (IP: %s) \n", host->h_name,
           atoi(argv[2]), inet_ntoa(*(struct in_addr*)host->h_addr_list[0]));

    remote_address.sin_family = host->h_addrtype;
    memcpy((char*) &remote_address.sin_addr.s_addr,
           host->h_addr_list[0], host->h_length);
    remote_address.sin_port = htons(atoi(argv[2]));

    // Socket creation
    socket_descriptor = socket(AF_INET, SOCK_DGRAM, 0);
    if (socket_descriptor < 0)
    {
        printf("%s: cannot open socket \n", argv[0]);
        exit(1);
    }

    // Bind any port
    local_address.sin_family = AF_INET;
    local_address.sin_addr.s_addr = htonl(INADDR_ANY);
    local_address.sin_port = htons(0);

    return_code = bind(socket_descriptor, (struct sockaddr*) &local_address,
                       sizeof(local_address));

    if (return_code < 0)
    {
        printf("%s: cannot bind port\n", argv[0]);
        exit(1);
    }

    // Initialize the decoder with the chosen symbols and symbol size
    symbols = atoi(argv[3]);
    packets = atoi(argv[4]);

    if (packets < symbols)
    {
        printf("%s: number of packets should be higher than %d \n",
               argv[0], symbols);
    }

    // Create the decoder
    encoder = krlnc_create_encoder(finite_field, symbols, symbol_size);

    // Create the buffer needed for the payload
    payload_size = krlnc_encoder_max_payload_size(encoder);
    payload = (uint8_t*)malloc(payload_size);

    // Create some data to encode
    block_size = krlnc_encoder_block_size(encoder);
    data_in = (uint8_t*)malloc(block_size);

    for (i = 0; i < block_size; ++i)
        data_in[i] = rand() % 256;

    // Send data
    for (i = 0; i < packets; ++i)
    {
        if (krlnc_encoder_rank(encoder) < krlnc_encoder_symbols(encoder))
        {
            // The rank of an encoder indicates how many symbols have
            // been added, i.e. how many symbols are available for encoding
            uint32_t rank = krlnc_encoder_rank(encoder);

            // Calculate the offset to the next symbol to insert
            uint8_t* symbol = data_in + rank * symbol_size;
            krlnc_encoder_set_symbol_storage(encoder, symbol, rank);
        }

        bytes_used = krlnc_encoder_produce_payload(encoder, payload);
        printf("Payload generated by encoder, rank = %d, bytes used = %d\n",
               krlnc_encoder_rank(encoder), bytes_used);

        return_code = sendto(socket_descriptor, payload, bytes_used, 0,
                             (struct sockaddr*) &remote_address,
                             sizeof(remote_address));

        if (return_code < 0)
        {
            printf("%s: cannot send data %d \n", argv[0], i-1);
            close(socket_descriptor);
            exit(1);
        }

        sleep_here(delay);
    }

    // Clean up
    free(data_in);
    free(payload);

    krlnc_delete_encoder(encoder);

    return 0;
}
